# Backlog

|Priority (L/M/H)|Topic          |Category       |Effort (L/M/H)|Collected notes|
------------- |-------------| ---- | --- | --- 
H|Merge 'Languages' and 'Frameworks' sections| - |M| - 
L|WCF connection patterns|Languages/C#|M|`Dispose` vs `Close`+`Abort`, proper use `ChannelFactory<T>`, caching (what and why)
L|SCIM2|Architecture/General|L|SCIM2 is an API open standard for cross domain identity management
L|PIM/PAM|Architecture/General|M|Class of solutions that manage elevated permission accounts and their sessions (ie. admins, super-users and so on)
M|CMM|Architecture/General|M|*Capability Maturity Model* - development model for assessing how mature particular processes are in certain organization/department/project; this can span from things like DevOps maturity, cloud-readiness, quality gates, code-review, self-organisation etc; measurement ("scoring") spans from 1 (Initial) to 5 (Effective)
H|SQL Server locking debugging|Languages/SQL|L|Expand current *T-SQL Performance Analysis Cheatsheet* with `sp_lock` and `sp_who` + SPID
M|XAdES|Engineering/Security|H|XML signing - expand on how it actually works "underneath"; used for **qualified electronic signature** (recommended by UE and MSWiA in Poland)
H|SQL Server - `UPDLOCK` vs `SERIALIZABLE`|Languages/SQL|M|`UPDLOCK` hint can be used instead of `SERIALIZABLE` isolation level to prevent duplicates `INSERT` in (`SELECT` then `INSERT` scenario); it can gracefully force other sessions (that also use this hint) to wait for their "chance" to SELECT without ending up with deadlocks (as in `SERIALIZABLE` case)
M|SQL Server - lock compatibility matrix|Languages/SQL|M|Describe compatibility matrix between Shared (S), Exclusive (X), Update (U) and all the Intent types (I...)
M|SQL Server - `RoundTimeDown`|Languages/SQL|L|Describe creating time buckets in SQL Server with `RoundTimeDown`; quite handing for reporting and all time series oriented data in SQL Server
M|OpenTelemetry|Architecture/General|H|Describe OpenTelemetry - it's goals, current state and usage; from their page it `is a collection of tools, APIs, and SDKs. You can use it to instrument, generate, collect, and export telemetry data (metrics, logs, and traces) for analysis in order to understand your software's performance and behavior.`
M|Microfrontends|Architecture/Distributed|H|Describe Microfrontends as a general approach to decomposing monolithic frontends and as a final step in *vertical slices* approach to succeed
L|Webpack Module Federation vs single-spa|Languages/JavaScript|H|Describe differences between these two approaches and how they can be used to achieve microfrontends when needed
M|TailwindCSS|Languages/CSS|H|TailwindCSS has been gathering large popularity for a long time already; investigate and write down in your words how it works and "why the hype"
L|StencilJS|Languages/JS|H|StencilJS has been recommended in many places as a go-to solution for Web Components (and building design systems with them); investigate and write down how in general it works
L|RBAC,ABAC,ACL|Architecture/General|M|Briefly desribe RBAC, ABAC (RBAC + attributes) and RBAC (business role - create, write, enslist, pay etc.) vs ACL (technical - has or has not access to resource)
M|Marshalling|Engineering/Distributed computing|M|Briefly desribe definition of marshalling and find few examples of it like RPC/REST (with JSON/XML/MessagePack etc.), COM etc; compare with serialization
H|Linux commands cheatsheet|Languages/Linux commands|M|Describe commonly used Linux commands, especially `find`, `grep`, `sed`, `awk`, `cat`, `touch`, `mkdir`, `ls`, `virtualenv` and others
M|x86 assembly basics|Languages/Assembly|H|"Serialize" notes from reading ***C.O.D.E.***; note down popular x86 opcodes to be not so ignorant when reading x86 ASM files
H|How computer works? - high level|Engineering/Computer Science|H|Create simple cheatsheet (with diagrams) on how computer architecture works, ie. CPU (ALU, registers and L1, L2, L3 cache), memory, disc, bus speed and ideas/problems around it, ie. cache misses, branch prediction, register spilling (moving to RAM) etc.
L|Shift left|Architecture/General|L|"Shift left" is an organisation approach to security, that encourages security review as early in development process as possible (so "left" means literally left on time axis given software development lifetime)
L|Sonar vs Fortify|Standalone software/CICD|H|Both tools are used for static code analysis; Sonar is used for for code quality analysis (and measuring technological debt), whereas Fortify is used for code security analysis; compare how they can be used together in CI/CD pipeline
H|Certificates in PKCS|Engineering/Security|H|Describe what role certificates play in Public Key Cryptography Standards (PKCS) infrastructure; describe what thumbrint (hashed certificate), signature, CA (Certificate Authority) and trust chain is; throwing in few words about asymmetric cryptography wouldn't hurt
M|Array pooling with `ArrayPool<T>`|Languages/C#|M|*Array pooling* is a concept of initializing large array beforehand (if we anticipate that we will be allocating large arrays and do it a lot) and then renting chunks from it when we need them; if we keep renting from once preallocated pool, we do not end up with lots large arrays on LOH (Large Object Heap), that can later on cause forced managed heap collection (which hurts performance a lot); `ArrayPool<T>` offers pooling and renting (with `ArrayPool<T>.Rent`) functionality in .NET and is thread-safe; Adam Sitnik has amazing post about it on https://adamsitnik.com/Array-Pool/
H|Small Object Heap (G0, G1, G2) and Large Object Heap|Languages/C#|H|Write down general mechanism behind .NET Garbage Collection, SOH (and its generations) and LOH; include topics like LOH compacting, memory fragmentation problem, when object lands on LOH and general LOH problems; definitely approach with Konrad Kokosa's book accompanying you
L|tcpdump on Linux|Engineering/Computer networks|M|Describe usage of tcpdump - network sniffer for Linux; could be worth comparing it briefly with Wireshark
L|TLS termination|Engineering/Computer networks|M|Describe TLS/SSL termination - how it works, why we do this (performance, network appliance, package analysis etc.)
L|FQDN vs hostname|Engineering/Computer networks|L|Hostname could be FQDN if it goes up to the top-level domain
M|Load balancing - L4 vs L7|Engineering/Computer networks|H|Describe how load balancing is implemented nowadays, especially comparing layer 4 and layer 7 balancing; if it ends up as not a technical but more general note, move to Architecture/Distributed
M|HAProxy|Standalone software|M|Play around with HAProxy and note some general concepts behind how it works
H|async-await vs locking|Languages/C#|M|Write down approaches to using async-await with locking (mainly `SemaphoreSlim`, but could also hackaround your way with simple bit flag and `Interlocked.CompareExchange`)
M|Raft algorithm|Engineering/Distributed computing|H|Describe Raft algorithm and how it achieves cluster consensus with distributed log, leader election etc; note actual uses in solutions like Neo4j (+ONgDB) or RabbitMQ (with quorum queues)
L|Byzantine generals problem (Byzantine fault)|Engineering/Computer science|M|Describe Byzantine fault problem and how it affects distributed computing systems
H|Event schema changes - challenges|Architecture/Distributed|M|Describe solutions to adapt to changing event schemas, especially with event sourcing approach, where multiple versions changing over time can't be guaranteed to properly deserialize to strongly-typed event type; solutions I can think of would be *upcasting* along with usage of *weak schema* (for ex. JSON); consider describing *snapshot* creation too
L|OSINT|Architecture/General|M|Describe (from high level perspective) what open-source intelligence approach is and why you should care in terms of information security
M|Business validation - close to input or in core domain|Architecture/General|M|Describe current thoughts on (especially basic, ie. form) validations outside of core business domain with libraries like `FluentValidation` or `MVC Model validation`, that can offload trivial checks like required, min/max length, pattern match etc; discuss challenges of (possibly) missed rule enforcement in domain model, that can lead to breaking invariants and persisting domain model in invalid state 
M|Angular - performance pitfalls and patterns|Languages/TypeScript/Angular|H|Describe common Angular pitfalls like *methods and properties binding* (Angular has to check them on schedule with zone.js); describe common performance practices like `trackBy` + `ngFor`, *module lazy loading* (to lower initial CPU and network load), caching HTTP responses (especially slowly changing data) and either manualy change detection triggering with `ChangeDetectionRef` or using `OnPush` detection strategy along with immutable data; bonus topic - offloading long running tasks to *WebWorkers*
H|Angular - change tracking strategies|Languages/TypeScript/Angular|H|Describe how change tracking strategies work in Angular: *default* (with "deeper" checking and mutability support), *OnPush* (shallow, preferred for immutable data) and *disabled* (and manualy triggering using `ChangeDetectionRef`); describe briefly how `Zone.js` works with Angular; decribe how change detection mechanism work with templates (`foreach` + every *template binding* + compare previous value of field with current value but **only for those that are used in bindings**)
M|`[ThreadStatic]` vs `ThreadLocal<T>`|Languages/C#|M|Describe diffferences between `[ThreadStatic]` and `ThreadLocal<T>`; both are used for thread exclusive data (so each thread has its own copy), but `[ThreadStatic]` initializes for first thread only whereas `ThreadLocal<T>` initializes for every thread; `ThreadLocal<T>` also implements `IDisposable` (good for some cleanup); for keeping data local only to particular async flow (async-await chaing) you can also use `AsyncLocal<T>`
M|C# 9 records|Languages/C#|M|Describe how `record` - new C# (9.0) language feature - works; in general records have been introduced for implementing (reference) types, that are described by their data (so for ex. DTOs fit in here), offering out-of-the-box value equality. While meant mostly for immutable scenarios (by default they are immutable with auto-properties with `init` only setters), they can also be mutable. Records support nondestructive mutation (more like pure functional) with `with` keyword, that copy source record and apply given mutation on it, ie. `var secondRecord = firstRecord with { MyProp = "new value" }`. Another great productivity shorcut that records provide is a *positional syntax*, which allows us to define data-type in single line, ie: `public record Person(string firstName, string lastName, DateTime birthDate);` would yield encapsulated, immutable reference type with value equality implemented behind the scenes.
S|Angular - compare *dirty*, *touched* and *updateValueAndValidity*|Languages/TypeScript/Angular|M|Compare *dirty*, *touched* and *updateValueAndValidity* in Angular Forms and describe when and why should each of them be used.
H|Describe formal difference between *system* and *business* analysis|Architecture/Business analysis|M|Describe differences between system and business analysis. It seems that definition of business/system *analytic* and business/system *analysis* differ, as system analysis (according to Wikipedia and some other pages) is a subset of business analysis, which deals with translating organisation's needs, models and workflows into IT systems functionalities. On the other hand, it seems that business analytic does not deal directly with system analysis, even though it's a part of business analysis as a whole. Perhaps for practical reasons system analytic's work has been extracted from business analytic's responsibility list to allow division of work (and also specialization).
M|*Service blueprint* technique|Architecture/Business analysis|M|Describe *service blueprint* technique on how to plot a diagram of how particular service (let's take order as an example: order->pay->package->delivery) is being realized from high level perspective. Service blueprint consits of actors (placed on vertical/Y axis) and steps to deliver service (placed on horizontal/X axis). It also includes visibility boundry, which allows to distinguish processes that are visible to user (above boundry) and those, that happen "behind the scenes" (below boundry).
H|*Replication events* streaming via audit log or change tracking/change data capture|Architecture/Distributed|H|Describe my approach to building local storages around autonomous systems/modules/microservices etc. with audit log scanning or - if available - scanning Change Tracking (SQL Server) or Change Data Capture (SQL Server or PostgreSQL) and publishing results as either strongly typed (if in homogenous environment) or a weakly typed (if in polyglot environment) replication events.
L|`AsyncLock` by Stephen Cleary based on Stephen Toub MSDN article|Languages/C#|M|Describe a `AsyncLock` implementation, that simplifies mutual exclusion in async-await scenario (using `SemaphoreSlim` and `IDisposable` with `using` pattern behind the scenes)
H|Mutex, lock, semaphore, monitor, barrier, spinlock, RCU locks|Engineering/Computer science|H|Describe synchronization implementations used nowadays, including mutex, lock, semaphore, monitor, memory barrier/fence, spinlock, read-copy-update and readers-writer locks. It wouldn't hurt to mention read-modify-write, fetch-and-add and test-and-set operations. Why `volatile` keyword is important should also be mentioned here.
H|Compare HTTP Codes vs 200 + `{ errors: [] }` approach to business error handling|Architecture/Distributed|M|Discuss on how and when HTTP code for each class of problem (4xx) in RESTful APIs would be a better choice than 200s + errors in payload. Perhaps there should be some middle ground (especially for business validations) introduced as *catch-all* mechanism? I can think of returning every business error as 422 (Unprocessable Entity) to indicate business error (monitoring or client-side libraries auto-detect 4xx and 5xx as errors) along with payload decribing what went wrong. I'm typically against using HTTP codes in general as results of business rules violation, because I treat them as *technical errors*. So either input was malformed (serialization issue?), server refused to authorise user or simply such endpoint does not exist. Or maybe server just exploded and all we know is that 500 - Internal Server Error. However, I can understand how this can be misleading, that API returns 200 - OK for errors, even if there is a reason in a payload. When exposed to the outside world, I would probably go with 422 route + `{ errors: []}` approach.
M|SQL Server security model|Engineering/Infrastructure/Databases|L|Describe basics of SQL Server security model: login, mapping login to user on particular database, creating role on such database, assigning user to it and assigning permissions to certain objects to that role.
M|What is Istio?|Engineering/Distributed|M|Describe what is Istio and what problems it solves, ie. traffic management (routing, policies, load balancing, service discovery, staging and rolling releases etc.), observability (metrics, healthchecks, distributed tracing, access logs) and security (mostly certs and authorization, for ex. JWT access rules on service-level); also it would be useful to compare Envoy sidecar proxy Istio utilizes on service-level with kube-proxy in Kubernetes that works on node-level; briefly descrive data plane and control pane in Istio.
L|Kubernetes Ingress vs alternatives (Traefik, HAProxy, Istio Ingress)|Engineering/Distributed|H|Compare popular Kubernetes Ingress alternatives and write few bullet points when it's worth switching to one of them.
M|Domain (private) events vs integration (public) events|Architecture/General|L|Compare domain and integration events along with use cases;domain events - internal communication in-memory between aggregates in same bounded context/service boundry; integration events - out-of-process for external services, modules or even systems that are meant to do something with it in async manner